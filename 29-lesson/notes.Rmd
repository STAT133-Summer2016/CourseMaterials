---
title: "lesson29"
author: "Andrew Do"
date: "August 1, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

## Connecting to a database

To connect to a SQL database, you'll need to use the appropriate `src_*` function.  This tells `R` where to look for data, but unlike our `read_*` functions, the data is not stored into memory.

```{r}
chinook <- src_sqlite("Chinook_Sqlite.sqlite")
```

Once you've connected to a database, you can see what tables are available by calling on the connection:
```{r}
chinook
```

To actually see a table, you use the `tbl` function.  `tbl` is actually used in a second way, which we'll talk about soon.
```{r}
chinook %>% tbl("Album")
```

## Relational databases

Up until this point, when we've been using the tidy data model in which we think of our observations as being single rows of our data frame with all variables of interest contained in this single flat table.  While this certainly makes plotting and analyzing much easier, it's not a very scalable model---a naive wrangling sequence can generate temporary tables that are too large for memory.

Enter the relational database model where we store our data in multiple related tables.  The `chinook` dataset we'll be looking at today has the following __schema__, which is just a fancy word meaning "how the data is organized".

![Chinook Data Schema](ChinookDatabaseSchema.png)

By far, the most successful and widespread language for data administration, storage, and manipulation is SQL, which stands for Structured Query Language.  While there are many implementations of SQL, including MySQL, NoSQL, PostGreSQL, SQLite, etc., their basic functionalities are more or less the same with the main differences being availability of advanced functions.  We will mainly focus on SQLite since it's very quick to use with the `dplyr` package.

Another thing to note is that SQL has three major components.  It is a:

* Data Definition Language
    + Allows for creation and modification of relational schema
    + Schema objects include relations, indexes, etc
* Data Manipulation Language
    + Insert, delete, update rows in tables
    + Query data in tables
* Data Control Language
    + Concurrency control, transactions
    + Administrative tasks, e.g. set up database servers, security permissions

Our focus will be on a bullet subpoint: querying existing data in tables.  Talking about all the nuances of databases can actually take an entire semester (take CS186 if you're interested).

## Conventions
SQL functions are not case-sensitive, meaning `SELECT`, `Select`, and `select` perform the same task.  __Attributes__ (column names), however, are case-sensitive, so `TITLE`, `Title`, and `title` will refer to different things.  The normal convention is to keep SQL functions in all caps.

## SELECT (well this looks oddly familiar)
Let's start with `SELECT` as your first function.  The basic syntax is
`SELECT column_list FROM table_list`

For example, I'll build our first query from the `Track` table:
```{r}
my_first_query <- sql("
  SELECT
    trackid,
    name,
    composer,
    unitprice
  FROM
    Track
")
```

And to execute:
```{r}
chinook %>% tbl(my_first_query)
```

A few of things to note:

* To construct a SQL call with `dplyr`, you need to provide the query as a string to the `sql` function.
* The whitespace isn't necessary---I could have equivalently done
```{r, eval = FALSE}
sql("SELECT trackid,name,composer,unitprice FROM Track")
```
* To run the query, I use the `tbl` function with the connection as my first argument and the query as my second.

To select all the columns from a table, use the asterisk `*`
```{r}
my_second_query <- sql("
  SELECT * FROM Track
")
chinook %>% tbl(my_second_query)
```

Notice that `dplyr` doesn't actually load all of the data from the query.  This is to save you from accidentally pulling in huge amounts of data and killing your memory.  If you want more than the first 10 rows, you use the `collect` function and specify how many rows you want to see.  To see the result of the entire query, specify `n = Inf`.
```{r}
chinook %>% tbl(my_first_query) %>% collect(n = 5)
chinook %>% tbl(my_first_query) %>% collect(n = Inf)
```

The printout looks similar, but notice that the object is now a `tibble` with a specific number of rows rather than a `query` with `??` rows.

## ORDER BY

`ORDER BY` is pretty straightforward.  It comes after the `FROM` clause, and you can specify ascending or descending with `ASC` and `DESC`.  I'll just provide some examples:

```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    milliseconds, 
    albumid
  FROM
    Track
  ORDER BY
    albumid ASC
"))
```

The `ASC` is actually unnecessary since it's the default.  You can also sort on multiple columns.  This works the same way as `arrange` does in `dplyr`

```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    milliseconds, 
    albumid
  FROM
    Track
  ORDER BY
    albumid ASC,
    milliseconds DESC
"))
```

You can also specify the ordering by column position.  The index refers to the position specified in the `SELECT` clause.  Here 3 refers to `albumid` and 2 refers to `milliseconds`.

```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    milliseconds, 
    albumid
  FROM
    Track
  ORDER BY
    3,2
"))
```

## SELECT DISTINCT (huh, more similarities)

You'll often run into the case where selecting only a subset of the attributes leads to duplicates in your data

```{r}
chinook %>% tbl(sql("
  SELECT
    city
  FROM
    Customer
  ORDER BY
    city
")) %>% collect
```

Notice that Berlin appears twice.  What if we want a list of distinct cities for our customers?  In comes `SELECT DISTINCT`, which removes duplicate ROWS.

```{r}
chinook %>% tbl(sql("
  SELECT DISTINCT
    city
  FROM
    Customer
")) %>% collect
```

## WHERE (aka filter)

`WHERE` fills in the role of `filter()` from `dplyr`.  It has the following syntax:

```
SELECT 
  column_list
FROM
  table
WHERE
  search_condition
```

### Comparison Operators

`WHERE` understands the following comparison operators

Operator | Meaning
-------- | ----------------------------------------------------------------
=        | Equal to
<> or != | Not equal to
<        | Less than
\>       | Greater than
<=       | Less than or equal to
>=       | Greater than or equal to

### Logical Operators

SQL does not have a dedicated logical data type, so logical values are represented by 1 and 0.

SQLite understand the following logical operators

Operator | Meaning
-------- | -----------------------------------------------------------------
ALL      | returns 1 if all expressions are 1.
AND	     | returns 1 if both expressions are 1, and 0 if one of the expressions is 0.
ANY	     | returns 1 if any one of a set of comparisons is 1.
BETWEEN	 | returns 1 if a value is within a range.
EXISTS	 | returns 1 if a subquery contains any rows.
IN	     | returns 1 if a value is in a list of values.
LIKE	   | returns 1 if a value matches a pattern
NOT	     | reverses the value of other operators such as NOT EXISTS, NOT IN, NOT BETWEEN, etc.
OR	     | returns true if either expression is 1

### Examples

```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    milliseconds,
    bytes,
    albumid
  FROM
    Track
  WHERE
    albumid = 1
")) %>% collect
```

Here is an example of a compound expression
```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    milliseconds,
    bytes,
    albumid
  FROM
    Track
  WHERE
    albumid = 1
    AND milliseconds > 250000
")) %>% collect
```

`IN` functions like well... `%in%` from base `R`.
```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    albumid,
    mediatypeid
  FROM
    Track
  WHERE
    mediatypeid IN (2, 3)
")) %>% collect
```

To negate a statement, use `NOT`
```{r}
chinook %>% tbl(sql("
  SELECT
    trackid,
    name,
    genreid
  FROM
    Track
  WHERE
    genreid NOT IN (1, 2, 3)
")) %>% collect
```


`LIKE` allows you to perform an inexact search. The `%` acts like `.*` in regular expressions.  Say for example, you want to find all `composer` with `Smith` in their name.
```{r}
chinook %>% tbl(sql("
  SELECT
    name,
    albumid,
    composer
  FROM
    Track
  WHERE
    composer LIKE '%Smith%'
  ORDER BY
    albumid
")) %>% collect
```

`_` functions like `.` in regular expressions.  The following would be like searching for `".*Br.wn.*"`:

```{r}
chinook %>% tbl(sql("
  SELECT
    trackid,
    name
  FROM
    Track
  WHERE
    name LIKE '%Br_wn%'
")) %>% collect

```
